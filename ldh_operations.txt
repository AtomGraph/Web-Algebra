You are a smart agent controlling a data management system. You have access to the following operations that allow you to load, query, and write RDF data. The operations are functions defined using pseudo-Python datatypes. Operation invocations (function calls) can be used where Callable is expected.
RDF<Turtle> type means RDF graph data written in Turtle format. Lists and Dicts are represented as JSON.
URL is a subset of URI and is accessible over HTTP. String values can be cast to URL and URI if they start with "http://" or "https://".

1. RESOLVE_URI(base: URL, slug: str) -> URL

This function creates a new document URL that is relative to the base URL. If the slug string is provided, then it is used as the relative path, otherwise a random UUID value is used as the slug. The slug value will be URL-encoded if necessary.
Note that the resulting URL always have to have a trailing slash.

Example:
RESOLVE_URI("http://dbpedia.org/page/Copenhagen")

Result: "http://dbpedia.org/page/Copenhagen/4ed43e6a-1906-45d2-944f-a824a4b74f78/"

2. GET(url: URL) -> RDF<Turtle>

This function loads RDF data from the specified URL and returns it in Turtle format.

Example:
GET("http://dbpedia.org/resource/Copenhagen")

Result (truncated for brevity):

"""
@prefix dbr:	<http://dbpedia.org/resource/> .
@prefix schema: <http://schema.org/> .

dbr:Copenhagen a schema:City ;
  schema: name "City of Copenhagen"@en .
...
"""

3. POST(url: URL, data: RDF<Turtle>) -> bool

This function appends the specified RDF data (in Turtle format) to the document located at the specified URL. It returns true (success) or false (failure).

Example:
POST("http://dbpedia.org/resource/Copenhagen",
"""
@prefix dbr:	<http://dbpedia.org/resource/> .
@prefix schema: <http://schema.org/> .

dbr:Copenhagen schema:name "København"@da .
"""
)

Result: true

4. PUT(url: URL, data: RDF<Turtle>) -> bool

This function creates a new document at the specified URL (or replaces if there is one at that URL already) with the specified RDF data (in Turtle format) as its content. It returns true (success) or false (failure).

Example:
PUT("http://dbpedia.org/page/Copenhagen",
"""
@prefix foaf: <http://xmlns.com/foaf/0.1/> .
@prefix dbr:	<http://dbpedia.org/resource/> .

<http://dbpedia.org/page/Copenhagen> a foaf:Document,
  foaf:primaryTopic dbr:Copenhagen .
dbr:Copenhagen schema:name "København"@da .
"""
)

Result: true

5. SPARQL_STRING(question: str, endpoint: URL?) -> Union[Select, Describe]

This function accepts a natural language question and returns a valid SPARQL query string (either Select or Describe form) that provides a result which answers the query. An optional endpoint URL can be provided which could help you identify which dataset the query should be tailored for.
Use the Select form when you want to list resources and their property values and get a tabular result. Use the Describe form when you want to get RDF graph descriptions of one or more resources.
Where appropriate, use variable ?this to identify the subject(s) of the question. Also, do not project all variables using *, list all of the projected variable names explicitly.

Example:

SPARQL_STRING("Provide the description of the City of Copenhagen", "https://dbpedia.org/sparql")

Result: "DESCRIBE <http://dbpedia.org/resource/Copenhagen>"

6. SELECT(endpoint: URL, query: Select) -> List[Dict[str, Any]]

This function queries the provided SPARQL endpoint using the provided Select query string. It returns a tabular SPARQL result as a list of dictionaries in JSON form, where every dictionary represents a table row. The dictionary keys correspond to variables projected by the query. Key values are also dictionaries, with "type" field indicating the type of the value ("uri", "bnode", or "literal") and "value" providing the actual value. In case of language-tagged literals there is also an "xml:lang" key indicating the language code, and in case of typed literals there is a "datatype" key indicating the datatype URI.

Example: SELECT("https://dbpedia.org/sparql", "SELECT ?this ?name { ?this schema:name ?name }")

Result (truncated for brevity):

"""
[
  {
    "this": { "type": "uri", "value": "http://dbpedia.org/resource/Copenhagen" },
    "name": { "type": "literal", "value": "City of Copenhagen", "xml:lang": "en" }
  },
  {
    "this": { "type": "uri", "value": "http://dbpedia.org/resource/Copenhagen" },
    "name": { "type": "literal", "value": "København", "xml:lang": "da" }
  }
]
"""

7. DESCRIBE(endpoint: URL, query: Describe) -> RDF<Turtle>

This function queries the provided SPARQL endpoint using the provided Describe query string. It returns an RDF graph result.

Example:

DESCRIBE("https://dbpedia.org/sparql", "DESCRIBE <http://dbpedia.org/resource/Copenhagen>")

Result (truncated for brevity):

"""
@prefix dbr:	<http://dbpedia.org/resource/> .
@prefix schema: <http://schema.org/> .

dbr:Copenhagen a schema:City ;
  schema: name "City of Copenhagen"@en .
...
"""

8. MERGE(first: RDF<Turtle>, second: RDF<Turtle>) -> RDF<Turtle>

This function merges two RDF graphs (provided in Turtle syntax) into one, and returns the merged graph in the Turtle format.

Example:

MERGE(
"""
@prefix foaf: <http://xmlns.com/foaf/0.1/> .
@prefix dbr:	<http://dbpedia.org/resource/> .

dbr:Copenhagen a schema:City ;
  schema: name "City of Copenhagen"@en .
"""
,
"""
@prefix foaf: <http://xmlns.com/foaf/0.1/> .
@prefix dbr:	<http://dbpedia.org/resource/> .

dbr:Vilnius a schema:City ;
  schema: name "Vilnius"@en .
"""
)

Result:
"""
@prefix dbr:	<http://dbpedia.org/resource/> .
@prefix schema: <http://schema.org/> .

dbr:Copenhagen a schema:City ;
  schema: name "City of Copenhagen"@en .
dbr:Vilnius a schema:City ;
  schema: name "Vilnius"@en .
...
"""

9. PROJECT(table: List[Dict[str, Any]], var_names: List[str]) -> List[Dict[str, Any]]

This function projects the input table (list of dicts) into a new table so that only column names specified in var_names are kept.

Example:

PROJECT(
[
  {
    "this": { "type": "uri", "value": "http://dbpedia.org/resource/Copenhagen" },
    "name": { "type": "literal", "value": "City of Copenhagen", "xml:lang": "en" }
  },
  {
    "this": { "type": "uri", "value": "http://dbpedia.org/resource/Copenhagen" },
    "name": { "type": "literal", "value": "København", "xml:lang": "da" }
  },
  {
    "this": { "type": "uri", "value": "http://dbpedia.org/resource/Aarhus" },
    "name": { "type": "literal", "value": "Aarhus", "xml:lang": "da" }
  }
], "this")

Result:

[
  {
    "this": { "type": "uri", "value": "http://dbpedia.org/resource/Copenhagen" },
  },
  {
    "this": { "type": "uri", "value": "http://dbpedia.org/resource/Copenhagen" },
  },
  {
    "this": { "type": "uri", "value": "http://dbpedia.org/resource/Aarhus" },
  }
]

10. KEY_VALUE(row: Dict[str, Any], key: str) -> Any

This function retrieves a value from the provided row (structure as a Dict) for the given key.
The result of the function can be an atomic value or another Dict.

Example:

KEY_VALUE(
    KEY_VALUE(
        {
            "this": { "type": "uri", "value": "http://dbpedia.org/resource/Copenhagen" },
        },
        "this"
    ),
    "value"
)

Result: "http://dbpedia.org/resource/Copenhagen"

11. FOREACH_ROW(table: List[Dict[str, Any]], operation: Callable)

This function calls another function for every row in the provided table. The function call is passed using the operation argument.
FOREACH_ROW function is special function because it allows to use a special keyword $row in its body, which represents the Dict value of the current table row.

Example:

FOREACH_ROW(
[
  {
    "this": { "type": "uri", "value": "http://dbpedia.org/resource/Copenhagen" },
  },
  {
    "this": { "type": "uri", "value": "http://dbpedia.org/resource/Copenhagen" },
  },
  {
    "this": { "type": "uri", "value": "http://dbpedia.org/resource/Aarhus" },
  }
],
GET(KEY_VALUE($row, "this"))
)

There is no result returned, but the following function calls are executed:

GET("http://dbpedia.org/resource/Copenhagen")
GET("http://dbpedia.org/resource/Copenhagen")
GET("http://dbpedia.org/resource/Aarhus")

12. FORMAT_STRING(input: str, placeholder: str, replacement: str) -> str

This function formats the string by replacing occurences of the specified placeholder with the specified replacement value, and returns the formatted string.

Example:

FORMAT_STRING(FORMAT_STRING("<${this}> schema:name "${name}" .", "this", "http://dbpedia.org/resource/Copenhagen"), "name", "Copenhagen")

Result: "<$http://dbpedia.org/resource/Copenhagen> schema:name \"Copenhagen\" ."

##############################################

Please show how you would combine the operations (e.g. by using one functions result as an argument for another function) to execute such a task:

===================
Take "10 biggest cities in Denmark" as the question and query their titles and descriptions using SPARQL on https://dbpedia.org/sparql. For each of them, create a document with an URL relative to "http://localhost/denmark/" and write the respective city metadata into them.
===================

Please output the result of each step. First print the operation call, then the possible result after that. You are only allowed to use the provided operations, not custom code such as Python. If you are not able to express the task as operations, output an error and describe the reason.

##############################################

Please show how you would combine the operations (e.g. by using one functions result as an argument for another function) to execute such a task:

===================
Take "10 biggest cities in Denmark" as the question and query their titles and descriptions using SPARQL on https://dbpedia.org/sparql. For each of them, create a document with an URL relative to "http://localhost/denmark/", then get the RDF data for each city from its DBPedia's URI and put that data into the created document.
===================

Please output the result of each step. First print the operation call, then the possible result after that. You are only allowed to use the provided operations, not custom code such as Python. If you are not able to express the task as operations, output an error and describe the reason.